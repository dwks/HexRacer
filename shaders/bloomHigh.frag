varying vec3 eyeNormal;varying vec4 position;varying vec4 shadowPosition;uniform sampler2D glowMap;uniform sampler2D shadowMap;uniform int hasTexture [4];uniform int numLights;void main() {		if (hasTexture[2] == 1)		gl_FragColor = texture2D(glowMap, gl_TexCoord[0].st);	else		gl_FragColor = gl_FrontMaterial.ambient;			vec3 view = normalize(position.xyz);	vec3 reflection = normalize(reflect(view, eyeNormal));			float distanceFromLight = 1.0;	vec4 shadowCoordinateWdivide = vec4(0.0, 0.0, 0.0, 0.0);	if (hasTexture[3] == 1) {		shadowCoordinateWdivide = shadowPosition / shadowPosition.w;		shadowCoordinateWdivide.z -= 0.0005;		distanceFromLight = texture2D(shadowMap, shadowCoordinateWdivide.xy).z;	}		if (numLights > 0 && distanceFromLight > shadowCoordinateWdivide.z ) {		float light_dist = length((position-gl_LightSource[0].position).xyz);		float attenuation = min(1.0/(gl_LightSource[0].constantAttenuation + gl_LightSource[0].quadraticAttenuation*light_dist*light_dist), 1.0);		if (attenuation >= 0.004) {			vec3 light = normalize((position-gl_LightSource[0].position).xyz);						float kspec =-dot(reflection,light);			kspec = max( pow(kspec, gl_FrontMaterial.shininess) , 0.0);						gl_FragColor += gl_LightSource[0].specular*kspec*attenuation;		}	}			float depth_factor = max(pow(max(-position.z-20.0, 0.0), 2.0)*0.01, 1.0);	gl_FragColor.x = pow(gl_FragColor.x, 3.0)/depth_factor;	gl_FragColor.y = pow(gl_FragColor.y, 3.0)/depth_factor;	gl_FragColor.z = pow(gl_FragColor.z, 3.0)/depth_factor;}